<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"/>
    <title>配置指南 jetbrick-template</title>

    <link href="../assets/css/application.min.css" rel="stylesheet" type="text/css"/>

    <!--[if lt IE 9]><script src="../assets/js/html5shiv.js"></script><![endif]-->
    <script type="text/javascript" src="../assets/js/application.min.js"></script>
</head>

<body>
<a href="https://github.com/subchen/jetbrick-template/" target="_blank">
    <img src="../assets/images/forkme_right_orange.png" alt="Fork me on GitHub" class="fork-me-on-github">
</a>

<div class="jb-topbar">
    <div class="container">
        <a href="http://subchen.github.io/"><img src="../assets/images/logo-mini.png"/></a>
        <!--
        <ul class="menubar">
            <li><a href="">commons</a></li>
            <li><a href="">webmvc</a></li>
            <li><a href="">template</a></li>
            <li><a href="">orm</a></li>
            <li><a href="">widget</a></li>
            <li><a href="">javadoc-chm</a></li>
        </ul>
        -->
    </div>
</div>

<div class="jb-banner">
    <div class="container">
        <img src="../assets/images/jetbrick-template-logo.png" class="pull-left" />
        <ul class="description">
            <li>1. 全新一代 Java 模板引擎</li>
            <li>2. 具有高性能、高扩展性</li>
            <li>3. 完美替代 JSP, Velocity 等引擎模板</li>
        </ul>
        <a href="download/jetbrick-template-1.0.2.zip" class="download-button">
            <img src="../assets/images/download.png"/>
            <span>jetbrick-template-1.0.2.zip<br/>2013-11-22</span>
        </a>
    </div>
</div>

<div class="container">
    <div class="jb-section">
        <ul class="tabs">
            <li><a href="overview.html">简介</a></li>
            <li><a href="download.html">下载</a></li>
            <li><a href="userguide.html">开发指南</a></li>
            <li><a href="config.html" class="selected">配置指南</a></li>
            <li><a href="syntax.html">语法指南</a></li>
            <li><a href="integrate.html">框架集成</a></li>
            <!--
            <li><a href="example.html">例子</a></li>
            -->
            <li><a href="faq.html">FAQ</a></li>
        </ul>
    </div>
</div>

<div class="container">
    <div class="announcement">
        <a href="download.html#version">2013-11-22：jetbrick-template-1.0.2 版本已发布，欢迎使用和反馈。</a>
    </div>
</div>

<div class="container">

    <style type="text/css">
        .affix-top {
          float: left;
          margin-top: 20px;
        }
        .affix {
          position: left;
          float: right;
          top: 20px;
          margin-top: 0 !important;
          z-index: 100;
        }
        .jb-nav-list-container {
            width: 220px !important;
            margin-top: 20px;
        }
        .markdown {
          margin-left: 260px; 
        }
    </style>
    <div class="jb-nav-list-container" data-spy="affix" data-offset-top="230">
        <ul class="jb-nav-list">
            <li><a href="#x1106755817">1 全局配置选项</a></li>
            <li><a href="#x2097504848">&nbsp&nbsp1.1 全局包/变量/方法/函数</a></li>
            <li><a href="#x1497214921">&nbsp&nbsp1.2 模板路径和编码格式</a></li>
            <li><a href="#x1004799563">&nbsp&nbsp1.3 编译选项</a></li>
            <li><a href="#x867245599">&nbsp&nbsp1.4 注释指令</a></li>
            <li><a href="#x641838512">&nbsp&nbsp1.5 其他选项</a></li>
        </ul>
    </div>

    <div class="markdown">

<!-- markdown body begin -->
    <h1><a name="x1106755817"></a><span>1 全局配置选项</span></h1> 
<table> 
 <thead> 
  <tr> 
   <th>名称 </th> 
   <th>说明 </th> 
   <th>默认值 </th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>import.packages </td> 
   <td>默认导入的 java 包 </td> 
   <td> </td> 
  </tr> 
  <tr> 
   <td>import.classes </td> 
   <td>默认导入的 java 类 </td> 
   <td> </td> 
  </tr> 
  <tr> 
   <td>import.methods </td> 
   <td>默认导入的扩展方法 </td> 
   <td> </td> 
  </tr> 
  <tr> 
   <td>import.functions </td> 
   <td>默认导入的扩展函数 </td> 
   <td> </td> 
  </tr> 
  <tr> 
   <td>import.variables </td> 
   <td>默认导入的 java 对象 </td> 
   <td> </td> 
  </tr> 
  <tr> 
   <td>input.encoding </td> 
   <td>模板源文件的编码格式 </td> 
   <td>utf-8 </td> 
  </tr> 
  <tr> 
   <td>output.encoding </td> 
   <td>模板输出编码格式 </td> 
   <td>utf-8 </td> 
  </tr> 
  <tr> 
   <td>template.loader </td> 
   <td>模板资源载入Class </td> 
   <td>jetbrick.template.resource.loader.FileSystemResourceLoader </td> 
  </tr> 
  <tr> 
   <td>template.path </td> 
   <td>模板资源的根目录 </td> 
   <td>当前目录 </td> 
  </tr> 
  <tr> 
   <td>template.suffix </td> 
   <td>默认模板文件扩展名 </td> 
   <td>.jetx </td> 
  </tr> 
  <tr> 
   <td>template.reloadable </td> 
   <td>是否允许热加载 </td> 
   <td>false </td> 
  </tr> 
  <tr> 
   <td>compile.always </td> 
   <td>是否总是重新编译 </td> 
   <td>true </td> 
  </tr> 
  <tr> 
   <td>compile.debug </td> 
   <td>是否允许输出 debug 信息 </td> 
   <td>false </td> 
  </tr> 
  <tr> 
   <td>compile.path </td> 
   <td>默认编译输出路径 </td> 
   <td>系统TEMP目录 </td> 
  </tr> 
  <tr> 
   <td>trim.directive.line </td> 
   <td>是否要删除指令行两边的空白 </td> 
   <td>true </td> 
  </tr> 
  <tr> 
   <td>trim.directive.comments </td> 
   <td>是否支持指令两边增加注释对 </td> 
   <td>false </td> 
  </tr> 
  <tr> 
   <td>trim.directive.comments.prefix </td> 
   <td>指令注释的开始部分 </td> 
   <td>&lt;!– </td> 
  </tr> 
  <tr> 
   <td>trim.directive.comments.suffix </td> 
   <td>指令注释的结束部分 </td> 
   <td>–&gt; </td> 
  </tr> 
 </tbody> 
</table> 
<blockquote>
 <p><strong>注意</strong>：所有配置选项都必须在 <code>JetEngine</code> 初始化的时候指定，不允许动态修改。</p> 
</blockquote>
<h2><a name="x2097504848"></a><span>1.1 全局包/变量/方法/函数</span></h2>
<p>在模板中，如果要用到一些其他的 Class, 那么可以先 import 进来，这样就可以在模板中使用短名字，比如 <code>Date</code> 而不是 <code>java.util.Date</code>。</p>
<h3><a name="x2047664874"></a><span>1.1.1 import.packages</span></h3>
<p>用来配置包名，会自动导入包下面的所有类。允许配置多个包名，用逗号分隔。</p>
<h3><a name="x206485795"></a><span>1.1.2 import.classes</span></h3>
<p>用来配置单个类名，优先级比 <code>import.packages</code> 高。允许配置多个类名，用逗号分隔。</p>
<p>示例如下：</p> 
<script type="syntaxhighlighter" class="brush: text"><![CDATA[
import.packages = jetbrick.schema.app.model, jetbrick.schema.app.methods.*
import.classes = java.io.File, java.util.List
]]></script> 
<blockquote>
 <p><strong>注意</strong>：<code>jetbrick-template</code> 会自动引入 <code>java.lang.*</code> 和 <code>java.util.*</code>。</p> 
</blockquote>
<h3><a name="x937641362"></a><span>1.1.3 import.variables</span></h3>
<p>在一个 webapp 中，我们希望每个模板都自动引入一些变量，比如 <code>HttpServletRequest request</code>，那么我们就可以在这里定义。</p>
<p>允许配置多个变量定义，用逗号分隔。示例如下：</p> 
<script type="syntaxhighlighter" class="brush: text"><![CDATA[
import.variables = HttpServletRequest request
import.variables = jetbrick.orm.Pagelist pagelist, List<Entity> entites
]]></script>
<p>变量的类型可以使用泛型定义，并且会自动在 <code>import.packages</code> 和 <code>import.classes</code> 里面查找 Class。</p> 
<blockquote>
 <p><strong>注意</strong>：全局定义的变量如果在模板中被重新定义成其他类型(<code>#define</code>, <code>#set</code>)，则以模板定义优先。</p> 
</blockquote>
<h3><a name="x104572311"></a><span>1.1.4 import.methods</span></h3>
<p>我们知道一个 Java Class 的 所有 methods 都是定义在同一个 class 文件中的，不能在其他地方进行动态扩展。但是一些其他动态语言却支持在 Class 外部为这个 Class 增加一些方法。比如：</p> 
<ul> 
 <li>JavaScript 的 prototype 机制</li> 
 <li>Groovy 的 metaClass 机制</li> 
 <li>Kotlin</li> 
</ul>
<p>jetbrick-template 也在这里带给大家强大的动态方法扩展机制。具体参考： <a href="userguide.html#methods">jetbrick-template 动态方法扩展</a></p>
<p>这里就是把实现了动态扩展的 Method Class 注册到 JetEngine 中。允许配置多个 Class 定义，用逗号分隔。示例如下：</p> 
<script type="syntaxhighlighter" class="brush: text"><![CDATA[
import.methods = StringMethods, app.project.methods.UserAuthMethods
]]></script>
<p>定义的类名会自动在 <code>import.packages</code> 里面查找 Class。</p>
<p><code>jetbrick-template</code> 默认会注册 <code>jetbrick.template.runtime.JetMethods</code>，具体参考：<a href="syntax.html#default_methods">默认的方法扩展</a>。</p>
<h3><a name="x995736430"></a><span>1.1.5 import.functions</span></h3>
<p>和 <code>import.methods</code> 类似，我们还支持在模板中使用函数。</p>
<p>允许配置多个 Function Class 定义，用逗号分隔。示例如下：</p> 
<script type="syntaxhighlighter" class="brush: text"><![CDATA[
import.functions = app.project.methods.UserAuthFunctions
]]></script>
<p><code>jetbrick-template</code> 默认会注册 <code>jetbrick.template.runtime.JetFunctions</code>，具体参考：<a href="syntax.html#default_functions">默认的函数扩展</a>。</p>
<h2><a name="x1497214921"></a><span>1.2 模板路径和编码格式</span></h2>
<h3><a name="x1175775991"></a><span>1.2.1 input.encoding</span></h3>
<p>模板源文件的编码格式，默认为 <code>utf-8</code>。</p>
<h3><a name="x1773115296"></a><span>1.2.2 output.encoding</span></h3>
<p>模板输出内容的编码格式，默认为 <code>utf-8</code>。</p> 
<blockquote>
 <p><strong>注意</strong>：一般在 web 中，<code>output.encoding</code> 应该和 html 页面的 <code>contentType</code> 中的编码，以及 <code>response</code> 的 <code>characterEncoding</code> 完全一致。</p> 
</blockquote>
<h3><a name="x1970607097"></a><span>1.2.3 template.loader</span></h3>
<p>如何找到我们自己的模板文件呢？这里就是定义我们要使用的查找类。我们支持下面几种 Class</p> 
<script type="syntaxhighlighter" class="brush: text"><![CDATA[
template.loader = jetbrick.template.resource.loader.FileSystemResourceLoader
template.loader = jetbrick.template.resource.loader.ClasspathResourceLoader
template.loader = jetbrick.template.resource.loader.JarResourceLoader
]]></script>
<p>默认为 <code>jetbrick.template.resource.loader.FileSystemResourceLoader</code>。</p>
<h3><a name="x225407719"></a><span>1.2.4 template.path</span></h3>
<p>除了要定义 <code>template.loader</code>，我们还需要定义模板存放的根目录。</p>
<p>默认为系统当前目录：<code>System.getProperty(&quot;user.dir&quot;)</code>。</p> 
<ul> 
 <li>从文件系统加载</li> 
</ul> 
<script type="syntaxhighlighter" class="brush: text"><![CDATA[
template.loader = jetbrick.template.resource.loader.FileSystemResourceLoader
template.path = /opt/app/templates/
]]></script> 
<ul> 
 <li>从Classpath下加载</li> 
</ul> 
<script type="syntaxhighlighter" class="brush: text"><![CDATA[
template.loader = jetbrick.template.resource.loader.ClasspathResourceLoader
template.path = /META-INF/templates/
]]></script> 
<ul> 
 <li>从jar包中加载</li> 
</ul> 
<script type="syntaxhighlighter" class="brush: text"><![CDATA[
template.loader = jetbrick.template.resource.loader.JarResourceLoader
template.path = /opt/app/templates.jar
]]></script>
<h3><a name="x1764510907"></a><span>1.2.5 template.suffix</span></h3>
<p>默认的模板文件扩展名 <code>.jetx</code>，主要用于 Web 框架集成中，用于查找和过滤模板用。</p>
<h3><a name="x674610073"></a><span>1.2.6 template.reloadable</span></h3>
<p>在开发模式下面，我们一般需要频繁的修改模板内容来进行调试。那么我们需要打开这个功能来支持模板的热部署。（类似于 <code>JSP</code>）</p>
<p>是否需要重新编译和加载模板，取决于模板源文件的最后修改时间。</p>
<p>默认为 <code>false</code>，建议只在开发模式中启用。</p>
<h2><a name="x1004799563"></a><span>1.3 编译选项</span></h2>
<p>jetbrick-template 采用编译成 Java ByteCode 来提高性能。</p>
<h3><a name="x371822122"></a><span>1.3.1 compile.always</span></h3>
<p>是否总是在第一次访问模板的时候，重新编译模板，而不是从磁盘中读取已经编译好的 Class 文件。(1.0.2 开始支持)</p>
<p>默认 <code>true</code>，建议只在生产模式中关闭。</p> 
<blockquote>
 <p><strong>注意</strong>：默认开启的原因是：模板内使用的用户类或者接口可能已经发生了变化，这时候就能通过重新编译来连接到新的接口或者提前产生编译错误。而不会因为使用旧的版本而引发的一些莫名奇妙的问题。编译也只在第一次访问的时候执行，以后的访问就不需要重新编译了。基本不影响性能。</p> 
</blockquote>
<h3><a name="x1370936616"></a><span>1.3.2 compile.debug</span></h3>
<p>是否在日志中打印输出模板生成的 Java Source 源代码。</p>
<p>默认 <code>false</code>，建议在开发模式中启用。</p> 
<blockquote>
 <p><strong>注意</strong>：同时需要 slf4j 的配合才能输出日志。参数格式请查看 <a href="http://www.slf4j.org/apidocs/org/slf4j/Logger.html">Slf4j Logger</a>。</p> 
</blockquote>
<h3><a name="x94677760"></a><span>1.3.3 compile.path</span></h3>
<p>在模板编译的时候，会先生成对应的 <code>.java</code> 文件，然后在把 <code>.java</code> 文件编译成 <code>.class</code> 文件。我们生成的这 2 种文件就放在这个目录下面。</p>
<p>在用 Eclipse 进行 debug 的时候，可以 link 这个目录为 sourcepath 来进行 debug。具体参考：<a href="userguide.html#debug">如何调试模板 debug？</a></p>
<p>默认为系统TEMP目录：<code>System.getProperty(&quot;java.io.tmpdir&quot;)</code>。如果这个目录非法或者没有写的权限，那么就会抛出 Exception。</p> 
<blockquote>
 <p><strong>注意</strong>：我们会在这个目录中生成一个 jetx_{version} 的子目录，这个才是真正的 sourcepath。</p> 
</blockquote>
<h2><a name="x867245599"></a><span>1.4 注释指令</span></h2>
<p>由于目前的指令一般直接嵌入在 HTML，对于一些使用可视化编辑器的用户来说，可能会造成一些干扰。<br />模板从 1.0.1 开始增加对指令注释支持，如：<code>&lt;!-- #if (...) --&gt;</code>; 增强对可视化编辑器的友好度。</p>
<h3><a name="x557827583"></a><span>1.4.1 trim.directive.comments</span></h3>
<p>是否开启对注释指令的支持，默认为 <code>false</code>，表示不启用。</p>
<h3><a name="x777542303"></a><span>1.4.2 trim.directive.comments.prefix</span></h3>
<p>设置注释开始格式，默认为 <code>&lt;!--</code></p>
<h3><a name="x688854496"></a><span>1.4.3 trim.directive.comments.suffix</span></h3>
<p>设置注释开始格式，默认为 <code>--&gt;</code></p> 
<blockquote>
 <p><strong>注意</strong>： 如果开启注释指令的支持，系统并没有强制要求 <code>trim.directive.comments.prefix</code> 和 <code>trim.directive.comments.suffix</code> 必须配对出现。也就是说如果使用 <code>&lt;!-- #end</code> 也是可以的。当然我们还是建议你配对使用。</p> 
</blockquote>
<p>范例：</p> 
<script type="syntaxhighlighter" class="brush: text"><![CDATA[
<table>
<!-- #for (User user: userlist) -->
  <tr>
	<td>${user.name}</td>
	<td>${user.email}</td>
  </tr>
<!-- #end -->
</table>
]]></script>
<h2><a name="x641838512"></a><span>1.5 其他选项</span></h2>
<h3><a name="x1911663233"></a><span>1.5.1 trim.directive.line</span></h3>
<p>由于指令之间存在很多的空白内容，而空白内容也会被作为原始文本原封不动的输出，这样会造成很多输出的内容参差不齐。这个就是用来优化输出格式的，对于用模板来进行代码生成时候特别有用。不建议关闭。</p>
<p>模板示例：</p> 
<script type="syntaxhighlighter" class="brush: text"><![CDATA[
#for (int n: [1,2,3])
${n}
#end
]]></script>
<p>禁用后效果：<code>false</code></p> 
<script type="syntaxhighlighter" class="brush: text"><![CDATA[

1

2

3

]]></script>
<p>启用后的效果：<code>true</code> (默认启用)</p> 
<script type="syntaxhighlighter" class="brush: text"><![CDATA[
1
2
3
]]></script>
<!-- markdown body end -->

    </div>
</div>

<div class="container">
    <div class="jb-footer">
        Copyright 2010-2013 Guoqiang Chen. All rights reserved.
        <br/>subchen&#64;gmail.com
    </div>
</div>

<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F4cd7ebfba4427db2d448141e54dd358c' type='text/javascript'%3E%3C/script%3E"));
</script>

</body>
</html>
